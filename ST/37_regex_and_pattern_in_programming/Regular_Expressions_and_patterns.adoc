=  Regular Expression & pattern in programming
:doctype: book
:toc: left
:sectnums:

'''

== Introduction

=== What are Regular Expressions and pattern?

Regular Expressions, often called *regex*, are a powerful tool for finding patterns in text.
They allow you to search, match, and manipulate text efficiently.
A single line of regex can do the work of many lines of code.
Regex is commonly used in search engines, text editors, word processors, and for validating user input in programming.

*How Regex Works:*

A *regex pattern* is made up of characters that describe what you're looking for.
For example, the pattern *'\d+'* matches one or more digits.

In a regex pattern, each character has a role:

* *Literal characters* match exactly what they represent.
For example, the character *'b'* in a regex matches the letter 'b'.
* *Metacharacters* have special meanings.
For example, the dot *'.'* matches any character except a newline.
Websphere mq Examples:

* The pattern *'b.'* will match any two-character string that starts with 'b', like 'ba', 'b2', or 'b@'.
* The pattern *'[a-z]'* matches any lowercase letter from 'a' to 'z'.
* The pattern *'.'* matches any character, making it very general, while *'b'* matches exactly the letter 'b'.

*Strings and Regular Expressions:*

Both the patterns and the text you're searching through can be either Unicode strings or 8-bit strings (like bytes).
However, they must be of the same type to match properly.

* *Unicode Strings*: These can include characters from many different languages.
If you're searching a Unicode string, use a Unicode-compatible regex pattern.
* *8-Bit Strings*: Often used for binary data or older systems.
Use 8-bit regex patterns for these.
For example, if you're working with a Unicode string that contains Japanese text, your regex pattern should also be Unicode-aware to work correctly.

[TIP]
The metacharacter syntax is designed specifically to represent prescribed targets in a concise and flexible way to direct the automation of text processing of a variety of input data

=== What Are Regex Used For?

Regular expressions (regex) are powerful tools for solving a wide range of text-related problems.
Here are some examples of what you can accomplish with regex:

* Check if the pattern "ss" appears in the string "Mississippi."
* Determine whether the letter "p" occurs three or more times in "Mississippi."
* Find and replace all instances of "Mrs" with "Ms" in a document.
* Verify if a file name starts with "Bob" and ends with ".txt" or ".md."
* Identify if a string contains any non-alphanumeric characters.
* Validate if the user has entered a valid integer.
* Check for any whitespace characters in a string.
* Replace all non-alphanumeric characters in a string with a hyphen ("-").
* Locate all email addresses within a document.
* Split a line of text into fields, using whitespace as the delimiter between values.

== Regex Syntax Summary

* _Character_: All characters, except those having special meaning in regex, matches themselves.
E.g., the regex x matches substring "x"; regex 9 matches "9"; regex = matches "="; and regex @ matches "@".
* _Special Regex Characters_ (quantifiers): These characters have special meaning in regex : ., +, *, ?, ^, $, (, ), [, ], {, }, |, \.
A quantifier after an element (such as a token, character, or group) specifies how many times the preceding element is allowed to repeat.
The most common quantifiers are the question mark ?, the asterisk * (derived from the Kleene star), and the plus sign + (Kleene plus).

.Special Regex Characters
[%autowidth.stretch]
|===
|Quantifier|Description
|?
|The question mark indicates zero or one occurrences of the preceding element. For example, colou?r matches both "color" and "colour".
|*
|The asterisk indicates zero or more occurrences of the preceding element. For example, ab*c matches "ac", "abc", "abbc", "abbbc", and so on.
|+
|The plus sign indicates one or more occurrences of the preceding element. For example, ab+c matches "abc", "abbc", "abbbc", and so on, but not "ac".
|{n}
|The preceding item is matched exactly n times.
|{min,}|    The preceding item is matched min or more times.
|{,max}|    The preceding item is matched up to max times.
|{min,max}|    The preceding item is matched at least min times, but not more than max times.
|*?
|? after a quantifier makes it a reluctant quantifier. It tries to find the smallest match. This makes the regular expression stop at the first match
|() | Parentheses are used to define the scope and precedence of the operators (among other uses). For example, gray\|grey and gr(a\|e)y are equivalent patterns which both describe the set of "gray" or "grey".
|===

* _Escape Sequences (\char)_:
** To match a character having special meaning in regex, you need to use a escape sequence prefix with a backslash (\).
E.g., \. matches "."; regex \+ matches "+"; and regex \( matches "(".
** You also need to use regex \\ to match "\" (back-slash).
** Regex recognizes common escape sequences such as \n for newline, \t for tab, \r for carriage-return, \nnn for a up to 3-digit octal number, \xhh for a two-digit hex code, \uhhhh for a 4-digit Unicode, \uhhhhhhhh for a 8-digit Unicode

* _A Sequence of Characters (or String)_: Strings can be matched via combining a sequence of characters (called sub-expressions).
E.g., the regex Saturday matches "Saturday".
The matching, by default, is case-sensitive, but can be set to case-insensitive via modifier.

* _OR Operator (|)_: E.g., the regex four|4 accepts strings "four" or "4".
Most formalisms provide the following operations to construct regular expressions.
For example, gray|grey can match "gray" or "grey".

* _Character class (or Bracket List)_:
** [...]: Accept ANY ONE of the character within the square bracket, e.g., [aeiou] matches "a", "e", "i", "o" or "u".
** [.-.] (Range Expression): Accept ANY ONE of the character in the range, e.g., [0-9] matches any digit; [A-Za-z] matches any uppercase or lowercase letters.
** [^...]: NOT ONE of the character, e.g., [^0-9] matches any non-digit.
** Only these four characters require escape sequence inside the bracket list: ^, -, ], \.

* _Occurrence Indicators (or Repetition Operators)_:
** \+: one or more (1+), e.g., [0-9]+ matches one or more digits such as '123', '000'.
** \*: zero or more (0+), e.g., [0-9]* matches zero or more digits.
It accepts all those in [0-9]+ plus the empty string.
** ?: zero or one (optional), e.g., [+-]? matches an optional "+", "-", or an empty string.
** {m,n}: m to n (both inclusive)
** {m}: exactly m times
** {m,}: m or more (m+)

* _Position Anchors_: does not match character, but position such as start-of-line, end-of-line, start-of-word and end-of-word.
** ^, $: start-of-line and end-of-line respectively.
E.g., ^[0-9]$ matches a numeric string.
** \b: boundary of word, i.e., start-of-word or end-of-word.
E.g., \bcat\b matches the word "cat" in the input string.
** \B: Inverse of \b, i.e., non-start-of-word or non-end-of-word.
** \<, \>: start-of-word and end-of-word respectively, similar to \b. E.g.,`\<cat\>` matches the word "cat" in the input string.
** \A, \Z: start-of-input and end-of-input respectively.

* _Metacharacters_: matches a character
** *.* (dot): Any one character except newline.
Same as [^\n]
For example, +
`a.b` matches any string that contains an "a", and then any character and then "b". +
`a.*b` matches any string that contains an "a", and then the character "b" at some later point.
** \d, \D: Any one digit/non-digit character.
Digits are [0-9]
** \w, \W: Any one word/non-word character.
For ASCII, word characters are [a-zA-Z0-9_]
** \s, \S: Any one space/non-space character.
For ASCII, whitespace characters are [ \n\r\t\f]

* _Greediness, Laziness and Backtracking for Repetition Operators_

** *_Greediness of Repetition Operators_* *, +, ?, {m,n}`: The repetition operators are greedy operators, and by default grasp as many characters as possible for a match.
For example, the regex xy{2,4} try to match for "xyyyy", then "xyyy", and then "xyy".

** *_Lazy Quantifiers_* \*?, +?, ??, {m,n}?, {m,}?, : You can put an extra ? after the repetition operators to curb its greediness (i.e., stop at the shortest match).

** *_Backtracking_*: If a regex reaches a state where a match cannot be completed, it backtracks by unwinding one character from the greedy match.
For example, if the regex z*zzz is matched against the string "zzzz", the z* first matches "zzzz"; unwinds to match "zzz"; unwinds to match "zz"; and finally unwinds to match "z", such that the rest of the patterns can find a match.

** *_Possessive Quantifiers_* *+, ++, ?+, {m,n}+, {m,}+ : You can put an extra + to the repetition operators to disable backtracking, even it may result in match failure. e.g, z++z will not match "zzzz".
This feature might not be supported in some languages.
These constructions can be combined to form arbitrarily complex expressions, much like one can construct arithmetical expressions from numbers and the operations +, −, ×, and ÷.

[CAUTION]
*Book* "https://www.octawian.ro/fisiere/situri/asor/build/html/_downloads/23959de8d6104244fc49cc08032586b2/Fitzgerald_Regex.pdf[Regular Expression O'Really]"

== How to write regular expressions with hands-on examples

===  Numbers

`[0-9]+ or \d+`

* A regex (regular expression) consists of a sequence of sub-expressions.
In this example, [0-9] and +.
*  The [...], known as character class (or bracket list), encloses a list of characters. It matches any SINGLE character in the list. In this example, [0-9] matches any SINGLE character between 0 and 9 (i.e., a digit), where dash (-) denotes the range.
*  The \+, known as occurrence indicator (or repetition operator), indicates one or more occurrences (1+) of the previous sub-expression.
In this case, [0-9]+ matches one or more digits.
* A regex may match a portion of the input (i.e., substring) or the entire input.
In fact, it could match zero or more substrings of the input (with global modifier).
* This regex matches any numeric substring (of digits 0 to 9) of the input.
For examples,
** If the input is "abc123xyz", it matches substring "123".
** If the input is "abcxyz", it matches nothing.
** If the input is "abc00123xyz456_0", it matches substrings "00123", "456" and "0" (three matches).
* Take note that this regex matches number with leading zeros, such as "000", "0123" and "0001", which may not be desirable.
* You can also write \d+, where \d is known as a metacharacter that matches any digit (same as [0-9]).
There are more than one way to write a regex!
Take note that many programming languages (C, Java, JavaScript, Python) use backslash \ as the prefix for escape sequences (e.g., \n for newline), and you need to write "\\d+" instead.

=== Full Numeric Strings

`^[0-9]+$ or ^\d+$`

* The leading ^ and the trailing $ are known as position anchors, which match the start and end positions of the line, respectively.
As the result, the entire input string shall be matched fully, instead of a portion of the input string (substring).
* This regex matches any non-empty numeric strings (comprising digits 0 to 9), e.g., "0" and "12345".
It does not match with "" (empty string), "abc", "a123", "abc123xyz", etc.
However, it also matches "000", "0123" and "0001" with leading zeros.

=== Positive Integer Literals

`[1-9][0-9]*|0 or [1-9]\d*|0`

* [1-9] matches any character between 1 to the 9; [0-9]* matches zero or more digits.
The * is an occurrence indicator representing zero or more occurrences.
Together, [1-9][0-9]* matches any numbers without a leading zero.
* | represents the OR operator; which is used to include the number 0.
* This expression matches "0" and "123"; but does not match "000" and "0123" (but see below).
* You can replace [0-9] by metacharacter \d, but not [1-9].
* We did not use position anchors ^ and $ in this regex.
Hence, it can match any parts of the input string.
For examples,
** If the input string is "abc123xyz", it matches the substring "123".
** If the input string is "abcxyz", it matches nothing.
** If the input string is "abc123xyz456_0", it matches substrings "123", "456" and "0" (three matches).
** If the input string is "0012300", it matches substrings: "0", "0" and "12300" (three matches)!!!

=== Full Integer Literals

`^[+-]?[1-9][0-9]*|0$ or ^[+-]?[1-9]\d*|0$`

* This regex match an Integer literal (for entire string with the position anchors), both positive, negative and zero.
* [+-] matches either + or - sign. ? is an occurrence indicator denoting 0 or 1 occurrence, i.e. optional. Hence, [+-]? matches an optional leading + or - sign.
* We have covered three occurrence indicators: + for one or more, * for zero or more, and ? for zero or one.

=== Identifiers (or Names)

`[a-zA-Z_][0-9a-zA-Z_]* or [a-zA-Z_]\w*`

* Begin with one letters or underscore, followed by zero or more digits, letters and underscore.
* You can use metacharacter \w for a word character [a-zA-Z0-9_].
Recall that metacharacter \d can be used for a digit [0-9].

=== Image Filenames

`^\w+\.(gif|png|jpg|jpeg)$`

* The position anchors ^ and $ match the beginning and the ending of the input string, respectively.
That is, this regex shall match the entire input string, instead of a part of the input string (substring).
* \w+ matches one or more word characters (same as [a-zA-Z0-9_]+).
* \. matches the dot (.) character.
We need to use \. to represent . as . has special meaning in regex.
The \ is known as the escape code, which restore the original literal meaning of the following character.
Similarly, *, +, ? (occurrence indicators), ^, $ (position anchors) have special meaning in regex.
You need to use an escape code to match with these characters.
* (gif|png|jpg|jpeg) matches either "gif", "png", "jpg" or "jpeg".
The | denotes "OR" operator.
The parentheses are used for grouping the selections.
* The modifier i after the regex specifies case-insensitive matching (applicable to some languages like Perl and JavaScript only).
That is, it accepts "test.GIF" and "TesT.Gif".

=== Email Addresses

`^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$`

* The position anchors ^ and $ match the beginning and the ending of the input string, respectively.
That is, this regex shall match the entire input string, instead of a part of the input string (substring).
* \w+ matches 1 or more word characters (same as [a-zA-Z0-9_]+).
* [.-]? matches an optional character . or -. Although dot (.) has special meaning in regex, in a character class (square brackets) any characters except ^, -, ] or \ is a literal, and do not require escape sequence.
* ([.-]?\w+)* matches 0 or more occurrences of [.-]?\w+.
* The sub-expression \w+([.-]?\w+)* is used to match the username in the email, before the @ sign.
It begins with at least one word character [a-zA-Z0-9_], followed by more word characters or . or -.
However, a . or - must follow by a word character [a-zA-Z0-9_].
That is, the input string cannot begin with . or -; and cannot contain "..", "--", ".-" or "-.".
Example of valid string are "a.1-2-3".
* The @ matches itself.
In regex, all characters other than those having special meanings matches itself, e.g., a matches a, b matches b, and etc.
* Again, the sub-expression \w+([.-]?\w+)* is used to match the email domain name, with the same pattern as the username described above.
* The sub-expression \.\w{2,3} matches a . followed by two or three word characters, e.g., ".com", ".edu", ".us", ".uk", ".co".
* (\.\w{2,3})+ specifies that the above sub-expression could occur one or more times, e.g., ".com", ".co.uk", ".edu.sg" etc.

=== Swapping Words using Parenthesized Back-References

`^(\S+)\s+(\S+)$ and $2 $1`

* The ^ and $ match the beginning and ending of the input string, respectively.
* The \s (lowercase s) matches a whitespace (blank, tab \t, and newline \r or \n).
On the other hand, the \S+ (uppercase S) matches anything that is NOT matched by \s, i.e., non-whitespace.
In regex, the uppercase metacharacter denotes the inverse of the lowercase counterpart, for example, \w for word character and \W for non-word character; \d for digit and \D or non-digit.
* The above regex matches two words (without white spaces) separated by one or more whitespaces.
* Parentheses () have two meanings in regex:
** to group sub-expressions, e.g., (abc)*
** to provide a so-called back-reference for capturing and extracting matches.
* The parentheses in (\S+), called parenthesized back-reference, is used to extract the matched substring from the input string.
In this regex, there are two (\S+), match the first two words, separated by one or more whitespaces \s+.
The two matched words are extracted from the input string and typically kept in special variables $1 and $2 (or \1 and \2 in Python), respectively.
* To swap the two words, you can access the special variables, and print "$2 $1" (via a programming language);

===  HTTP Addresses

`^http:\/\/\S+(\/\S+)*(\/)?$`

* Begin with http://.
Take note that you may need to write / as \/ with an escape code in some languages (JavaScript, Perl).
* Followed by \S+, one or more non-whitespaces, for the domain name.
* Followed by (\/\S+)*, zero or more "/...", for the sub-directories.
* Followed by (\/)?, an optional (0 or 1) trailing /, for directory request.

==  Regex in Programming Languages

=== Regular Expressions in Java

Java doesn't include a built-in Regular Expression class, but you can work with regular expressions by importing the '*java.util.regex*' package.
This package provides several essential classes for handling regex:

image::images/java_regex_api.png[Tiger,600,150,float="center",align="center"]

** *Pattern Class*: Defines a regular expression pattern used in searches.
** *Matcher Class*: Performs search operations based on the pattern.
** *MatchResult Interface*: Holds the result of a match operation, providing methods to query the outcome of a regex match.
** *PatternSyntaxException Class*: Signals a syntax error in a regular expression pattern.

==== Pattern class

The *'Pattern'* class represents a compiled regular expression in Java.
To work with regular expressions using Java's regex API, you first need to compile the regular expression into a *'Pattern'* object.

Once compiled, a *'Pattern'* instance can be used to create *'Matcher'* objects that match strings against the regular expression.
Multiple *'Matcher'* instances can share the same *'Pattern'*, with state information managed separately within each *'Matcher'*.
This makes *'Pattern'* instances thread-safe and immutable.

Key methods and functionalities of the *'Pattern'* class include:

** *'asPredicate()'*: Creates a Java 8 predicate that can be used to match a string.
** *'static Pattern compile(String regex)'*: Compiles the given regular expression into a Pattern.
** *'static Pattern compile(String regex, int flags)'*: Compiles the given regular expression with the specified flags.
** *'int flags()'*: Returns the match flags for this pattern.
** *'Matcher matcher(CharSequence input)'*: Creates a Matcher to match the input against this pattern.
** *'static boolean matches(String regex, CharSequence input)'*: Compiles the given regular expression and matches it against the input.
** *'String pattern()'*: Returns the regular expression from which this pattern was compiled.
** *'static String quote(String s)'*: Returns a literal pattern string for the specified input.
** *'String[] split(CharSequence input)'*: Splits the input sequence around matches of this pattern.
** *'String[] split(CharSequence input, int limit)'*: Splits the input sequence around matches of this pattern, up to the specified limit.
** *'Stream splitAsStream(CharSequence input)'*: Creates a stream from the input sequence, split around matches of this pattern.

==== Matcher class

The *'Matcher'* class is the core component for performing match operations on a string or line by interpreting a *'Pattern'*.
Once a *'Matcher'* is created, it can execute various match operations.

This class also provides methods to replace matched subsequences with new strings, which can be dynamically generated from the match result.

Note: Instances of the *'Matcher'* class are not thread-safe.

Key methods of the *'Matcher'* class include:

** *boolean find()*: Searches for multiple occurrences of the regular expression in the text.
** *boolean find(int start)*: Searches for occurrences starting from a specified index.
** *int start()*: Returns the start index of the current match found by find().
** *int end()*: Returns the end index of the current match, pointing to the character just after the last matched character.
** *int groupCount()*: Returns the total number of matched subsequences.
** *String group()*: Retrieves the matched subsequence.
** *boolean matches()*: Tests whether the entire input sequence matches the pattern.
** *boolean lookingAt()*: Attempts to match the input sequence starting from the beginning.
** *String quoteReplacement(String s)*: Returns a literal replacement string for the specified string.
** *Matcher reset()*: Resets the matcher, clearing any state information.
** *MatchResult toMatchResult()*: Returns the current match state as a MatchResult.

.*Java Regex Examples:*
You first create a Pattern object which defines the regular expression.
This Pattern object allows you to create a Matcher object for a given string.
This Matcher object then allows you to do regex operations on a String.

[source,java]
----
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexExamples {

	public static void main(String[] args) {
		// using pattern with flags
		Pattern pattern = Pattern.compile("ab", Pattern.CASE_INSENSITIVE);
		Matcher matcher = pattern.matcher("ABcabdAb");
		// using Matcher find(), group(), start() and end() methods
		while (matcher.find()) {
			System.out.println("Found the text \"" + matcher.group()
					+ "\" starting at " + matcher.start()
					+ " index and ending at index " + matcher.end());
		}

		// using Pattern split() method
		pattern = Pattern.compile("\\W");
		String[] words = pattern.split("one@two#three:four$five");
		for (String s : words) {
			System.out.println("Split using Pattern.split(): " + s);
		}

		// using Matcher.replaceFirst() and replaceAll() methods
		pattern = Pattern.compile("1*2");
		matcher = pattern.matcher("11234512678");
		System.out.println("Using replaceAll: " + matcher.replaceAll("_"));
		System.out.println("Using replaceFirst: " + matcher.replaceFirst("_"));
	}
}
----

[NOTE]
*Java files for reference:* +
link:examples/Java/ValidateNumbers.java[ValidateRegexNumber] +
link:examples/Java/ValidateEmail.java[ValidateEmail] +
link:examples/Java/ValidateIpAddress.java[ValidateIpAddress] +
link:examples/Java/ValidatePhone.java[ValidatePhone]

====
*For additional information visit these resources:*

* https://docs.oracle.com/javase/tutorial/essential/regex/index.html[Java Framework Documentation for Regular Expressions]
* https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html[Pattern Class Java Documentation]
* https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html[Matcher Class Java Documentation]
* https://www.javatpoint.com/java-regex[Java regex]
====

=== Regular Expression in Python

Python has a built-in package called *re* (RegEx Module), which can be used to work with Regular Expressions.
Import the re module:

`import #re#`

When you have imported the re module, you can start using regular expressions:

[source,pyhton]
----
import re

txt = "The rain in Spain"
x = re.search("^The.*Spain$", txt)
----

.Popular Python re Module Functions
[%autowidth.stretch]
|===
|Function|Description

|re.findall(A, B) | Matches all instances of an expression A in a string B and returns them in a list.

|re.search(A, B) | Matches the first instance of an expression A in a string B, and returns it as a re match object.

|re.split(A, B) | Split a string B into a list using the delimiter A.

|re.sub(A, B, C) | Replace A with B in the string C.
|===

[NOTE]
*Python Regex Examples:* +
link:examples/Python/ValidateNumbers.py[ValidateNumber] +
link:examples/Python/ValidateEmail.py[ValidateEmail] +
link:examples/Python/ValidateIpAddress.py[ValidateIpAddress] +
link:examples/Python/ValidatePhone.py[ValidatePhone]

====
*For additional information visit these resources:*

* https://docs.python.org/3/howto/regex.html[Regular Expression HOWTO]
* https://realpython.com/regex-python/[Regexes in Python]
====

=== Regular Expression in JavaScript

There are two ways you can create a regular expression in JavaScript.

** Using a regular expression literal:

The regular expression consists of a pattern enclosed between slashes /.
For example,

[source,javascript]
----
const regularExp = /abc/;
----

Here, /abc/ is a regular expression.

** Using the RegExp() constructor function:
You can also create a regular expression by calling the RegExp() constructor function.
For example,

[source,javascript]
----
const reguarExp = new RegExp('abc');
----

.RegExp Object Methods
[%autowidth.stretch]
|===
|Method|Description

|compile()|    Deprecated in version 1.5. Compiles a regular expression
|exec()    |Tests for a match in a string. Returns the first match
|test()|Tests for a match in a string. Returns true or false
|toString()|    Returns the string value of the regular expression
|matchAll()|    Returns an iterator containing to all the matches.
|search()|    Tests for a match in a string and returns the index of the match. It returns -1 if the search fails.
|replace()|    Searches for a match in a string and replaces the matched substring with a replacement substring.
|split()|    Break a string into an array of substrings.
|===

[NOTE]
*JavaScript Regex Examples:* +
link:examples/JavaScript/ValidateNumbers.js[ValidateNumber] +
link:examples/JavaScript/ValidateEmail.js[ValidateEmail] +
link:examples/JavaScript/ValidateIpAddress.js[ValidateIpAddress] +
link:examples/JavaScript/ValidatePhone.js[ValidatePhone]

====
*For additional information visit these resources:*

* https://www.freecodecamp.org/news/regular-expressions-for-beginners/[How to Use Regular Expressions in JavaScript]
* https://www.programiz.com/javascript/regex[JavaScript Regex]
====

== Useful tools for regex validation and creation

For more information there are online tools to learn, build & test Regular Expression (RegEx/RegExp)

https://regex101.com/[regex101.com] +
https://regexr.com/[regexr.com] +
https://www.regextester.com/[regextester.com]

Created in 2024 by: +
link:mailto:andrei.diogoti@gmail.com[Andrei Diogoti] +
Edited by: +
Igor Gorea